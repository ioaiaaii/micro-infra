ingress-nginx:
  controller:
    allowSnippetAnnotations: true
    service:
      externalTrafficPolicy: "Local"    
      annotations: 
        cloud.google.com/network-tier: Standard
    autoscaling:
      enabled: true
      maxReplicas: 3
      targetCPUUtilizationPercentage: 70
      targetMemoryUtilizationPercentage: 80
    resources:
      limits:
        cpu: 50m
        memory: 150Mi
      requests:
        cpu: 10m
        memory: 150Mi
    affinity:
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: dedicated
              operator: In
              values:
              - infrastructure
    tolerations:
      - effect: NoSchedule
        key: dedicated
        operator: Equal
        value: infrastructure
    metrics:
      enabled: true
      serviceMonitor: 
        enabled: true
        additionalLabels:
          release: kube-prometheus-stack
    config:

      ### ModSecurity WAF https://kubernetes.github.io/ingress-nginx/user-guide/third-party-addons/modsecurity/#modsecurity-web-application-firewall
      enable-modsecurity: "true"
      # enable-owasp-modsecurity-crs: "true"

      # https://github.com/owasp-modsecurity/ModSecurity/blob/v3/master/modsecurity.conf-recommended
      # Update ModSecurity config and rules
      modsecurity-snippet: |
        # # this enables the mod security nextcloud plugin
        # Include /etc/nginx/owasp-modsecurity-crs/plugins/nextcloud-rule-exclusions-before.conf

        # # this enables the default OWASP Core Rule Set
        # Include /etc/nginx/owasp-modsecurity-crs/nginx-modsecurity.conf

        # Enable prevention mode. Options: DetectionOnly,On,Off (default is DetectionOnly)
        SecRuleEngine On

        # Enable scanning of the request body
        SecRequestBodyAccess On

        # Enable XML and JSON parsing
        SecRule REQUEST_HEADERS:Content-Type "(?:text|application(?:/soap\+|/)|application/xml)/" \
          "id:200000,phase:1,t:none,t:lowercase,pass,nolog,ctl:requestBodyProcessor=XML"

        SecRule REQUEST_HEADERS:Content-Type "application/json" \
          "id:200001,phase:1,t:none,t:lowercase,pass,nolog,ctl:requestBodyProcessor=JSON"

        # Send ModSecurity audit logs to the stdout (only for rejected requests)
        SecAuditLog /dev/stdout

        # format the logs in JSON
        SecAuditLogFormat JSON

        # could be On/Off/RelevantOnly
        SecAuditEngine RelevantOnly

        # Enable XML request body parser.
        # Initiate XML Processor in case of xml content-type
        #
        SecRule REQUEST_HEADERS:Content-Type "^(?:application(?:/soap\+|/)|text/)xml" \
            "id:'200000',phase:1,t:none,t:lowercase,pass,nolog,ctl:requestBodyProcessor=XML"

        # Enable JSON request body parser.
        # Initiate JSON Processor in case of JSON content-type; change accordingly
        # if your application does not use 'application/json'
        #
        SecRule REQUEST_HEADERS:Content-Type "^application/json" \
            "id:'200001',phase:1,t:none,t:lowercase,pass,nolog,ctl:requestBodyProcessor=JSON"

        # Sample rule to enable JSON request body parser for more subtypes.
        # Uncomment or adapt this rule if you want to engage the JSON
        # Processor for "+json" subtypes
        #
        #SecRule REQUEST_HEADERS:Content-Type "^application/[a-z0-9.-]+[+]json" \
        #     "id:'200006',phase:1,t:none,t:lowercase,pass,nolog,ctl:requestBodyProcessor=JSON"

        # Maximum request body size we will accept for buffering. If you support
        # file uploads then the value given on the first line has to be as large
        # as the largest file you are willing to accept. The second value refers
        # to the size of data, with files excluded. You want to keep that value as
        # low as practical.
        #
        SecRequestBodyLimit 13107200
        SecRequestBodyNoFilesLimit 131072

        # What to do if the request body size is above our configured limit.
        # Keep in mind that this setting will automatically be set to ProcessPartial
        # when SecRuleEngine is set to DetectionOnly mode in order to minimize
        # disruptions when initially deploying ModSecurity.
        #
        SecRequestBodyLimitAction Reject

        # Maximum parsing depth allowed for JSON objects. You want to keep this
        # value as low as practical.
        #
        SecRequestBodyJsonDepthLimit 512

        # Maximum number of args allowed per request. You want to keep this
        # value as low as practical. The value should match that in rule 200007.
        SecArgumentsLimit 1000


      ### Headers 

      ## Hiding exposure
      hide-headers: Server,X-Powered-By

      ## Proxying source headers information from LB
      # accept and forward upstream proxy headers
      use-forwarded-headers: "true"
      # use-proxy-protocol: "true"
      # get originating client request IP
      enable-real-ip: "true"
      # full Client Traceability during the transport
      compute-full-forwarded-for: "true"
      # original URI requested by the client is preserved and forwarded to the backend server as a custom header
      proxy-add-original-uri-header: "true"
  
      ### Hardening https://kubernetes.github.io/ingress-nginx/deploy/hardening-guide/#hardening-guide

      ## TLS
      #308 Permanent Redirect (redirect but change HTTP Method)
      force-ssl-redirect: "true"
      #301 Moved Permanently (redirect but keep HTTP Method)
      ssl-redirect: "true"
      #Use fresh and improved TLS Protocol 
      ssl-protocols: "TLSv1.3"       
      #ssl_prefer_server_ciphers directive will be enabled by default for http context
      #Use stronger chiphers 
      ssl-ciphers: "EECDH+AESGCM:EDH+AESGCM"
      #ssl-dh-param to be check later/needs secret
      # protocol that allows clients to check the revocation status of a TLS/SSL certificate with the Certificate Authority in real-time
      enable-ocsp: "true"
      ssl-session-tickets: "false"

      ### Observability

      ##Metrics
      # ServiceMonitor enabled from chart

      ##Tracing
      enable-opentelemetry: "true"
      opentelemetry-operation-name: "HTTP $request_method $service_name $uri"
      opentelemetry-trust-incoming-span: "true"
      otlp-collector-host: "otel-collector.observability.svc.cluster.local"
      otlp-collector-port: "4317"
      otel-max-queuesize: "2048"
      otel-schedule-delay-millis: "5000"
      otel-max-export-batch-size: "512"
      otel-service-name: "nginx-controller" # Opentelemetry resource name
      otel-sampler: "TraceIdRatioBased" # Also: AlwaysOff, TraceIdRatioBased
      otel-sampler-ratio: "0.1" #probability to sample requests
      otel-sampler-parent-based: "true"

      ##Logging
      log-format-escape-json: "true"
      enable-access-log-for-default-backend: "true"
      log-format-upstream: >-
        {
        "time":"$time_iso8601",
        "remote_addr":"$remote_addr",
        "x-forward-for": "$proxy_add_x_forwarded_for",
        "proxy_remote_addr": "$proxy_protocol_addr",
        "body_bytes_sent":"$body_bytes_sent",
        "bytes_sent": $bytes_sent,
        "host":"$host",
        "http_referrer":"$http_referer",
        "http_user_agent":"$http_user_agent",
        "x_forwarded_for":"$proxy_add_x_forwarded_for",
        "proxy_upstream_name":"$proxy_upstream_name",
        "request":"$request",
        "request_id":"$req_id",
        "request_length":"$request_length",
        "request_method":"$request_method",
        "request_path":"$uri",
        "request_proto":"$server_protocol",
        "request_query":"$args",
        "request_time":"$request_time",
        "status":"$status",
        "upstream_addr":"$upstream_addr",
        "upstream_response_length":"$upstream_response_length",
        "upstream_response_time":"$upstream_response_time",
        "upstream_status":"$upstream_status"
        }
